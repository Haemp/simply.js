/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 8);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* unused harmony export NameOrCtorDef */
/**
 * Copyright 2016 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/** @typedef {string|!Function} */
let NameOrCtorDef;





/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return initData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return importNode; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__types_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_js__ = __webpack_require__(2);
/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Keeps track of information needed to perform diffs for a given DOM node.
 * @param {NameOrCtorDef} nameOrCtor
 * @param {?string=} key
 * @param {*=} typeId
 * @constructor
 */
function NodeData(nameOrCtor, key, typeId) {
  /**
   * An array of attribute name/value pairs, used for quickly diffing the
   * incomming attributes to see if the DOM node's attributes need to be
   * updated.
   * @const {Array<*>}
   */
  this.attrsArr = [];

  /**
   * Whether or not the statics have been applied for the node yet.
   * {boolean}
   */
  this.staticsApplied = false;

  /**
   * The key used to identify this node, used to preserve DOM nodes when they
   * move within their parent.
   * @type {?string|undefined}
   */
  this.key = key;

  /**
   * Keeps track of children within this node by their key.
   * {!Object<string, !Element>}
   */
  this.keyMap = Object(__WEBPACK_IMPORTED_MODULE_1__util_js__["a" /* createMap */])();

  /**
   * Whether or the associated node is, or contains, a focused Element.
   * @type {boolean}
   */
  this.focused = false;

  /**
   * The nodeName or contructor for the Node.
   * @const {NameOrCtorDef}
   */
  this.nameOrCtor = nameOrCtor;

  /**
   * @type {?string}
   */
  this.text = null;

  /**
   * @const
   */
  this.typeId = typeId;
}


/**
 * Initializes a NodeData object for a Node.
 *
 * @param {Node} node The node to initialize data for.
 * @param {NameOrCtorDef} nameOrCtor The nodeName or constructor for the Node.
 * @param {?string=} key The key that identifies the node.
 * @param {*=} typeId The type identifier for the Node.
 * @return {!NodeData} The newly initialized data object
 */
const initData = function(node, nameOrCtor, key, typeId) {
  const data = new NodeData(nameOrCtor, key, typeId);
  node['__incrementalDOMData'] = data;
  return data;
};


/**
 * Retrieves the NodeData object for a Node, creating it if necessary.
 *
 * @param {?Node} node The Node to retrieve the data for.
 * @return {!NodeData} The NodeData for this Node.
 */
const getData = function(node) {
  importNode(node);
  return node['__incrementalDOMData'];
};


/**
 * Imports node and its subtree, initializing caches.
 *
 * @param {?Node} node The Node to import.
 */
const importNode = function(node) {
  if (node['__incrementalDOMData']) {
    return;
  }

  const isElement = node.nodeType === 1;
  const nodeName = isElement ? node.localName : node.nodeName;
  const key = isElement ? node.getAttribute('key') : null;
  const typeId = node['typeId'];
  const data = initData(node, nodeName, key, typeId);

  if (key) {
    getData(node.parentNode).keyMap[key] = node;
  }

  if (isElement) {
    const attributes = node.attributes;
    const attrsArr = data.attrsArr;

    for (let i = 0; i < attributes.length; i += 1) {
      const attr = attributes[i];
      const name = attr.name;
      const value = attr.value;

      attrsArr.push(name);
      attrsArr.push(value);
    }
  }

  for (let child = node.firstChild; child; child = child.nextSibling) {
    importNode(child);
  }
};


/** */



/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createMap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return has; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return truncateArray; });
/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * A cached reference to the hasOwnProperty function.
 */
const hasOwnProperty = Object.prototype.hasOwnProperty;


/**
 * A constructor function that will create blank objects.
 * @constructor
 */
function Blank() {}

Blank.prototype = Object.create(null);


/**
 * Used to prevent property collisions between our "map" and its prototype.
 * @param {!Object<string, *>} map The map to check.
 * @param {string} property The property to check.
 * @return {boolean} Whether map has property.
 */
const has = function(map, property) {
  return hasOwnProperty.call(map, property);
};


/**
 * Creates an map object without a prototype.
 * @return {!Object}
 */
const createMap = function() {
  return new Blank();
};


/**
 * Truncates an array, removing items up until length.
 * @param {!Array<*>} arr The array to truncate.
 * @param {number} length The new length of the array.
 */
const truncateArray = function(arr, length) {
  while (arr.length > length) {
    arr.pop();
  }
};


/** */




/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return patchInner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return patchOuter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return open; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return close; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return currentElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return currentPointer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return skip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return skipNode; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__types_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__nodes_js__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__node_data_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__assertions_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__dom_util_js__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__global_js__ = __webpack_require__(5);
/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/** @type {?Node} */
let currentNode = null;

/** @type {?Node} */
let currentParent = null;

/** @type {?Document} */
let doc = null;


/**
 * @param {!Array<Node>} focusPath The nodes to mark.
 * @param {boolean} focused Whether or not they are focused.
 */
const markFocused = function(focusPath, focused) {
  for (let i = 0; i < focusPath.length; i += 1) {
    Object(__WEBPACK_IMPORTED_MODULE_2__node_data_js__["a" /* getData */])(focusPath[i]).focused = focused;
  }
};


/**
 * Returns a patcher function that sets up and restores a patch context,
 * running the run function with the provided data.
 * @param {function((!Element|!DocumentFragment),!function(T),T=): ?Node} run
 * @return {function((!Element|!DocumentFragment),!function(T),T=): ?Node}
 * @template T
 */
const patchFactory = function(run) {
  /**
   * TODO(moz): These annotations won't be necessary once we switch to Closure
   * Compiler's new type inference. Remove these once the switch is done.
   *
   * @param {(!Element|!DocumentFragment)} node
   * @param {!function(T)} fn
   * @param {T=} data
   * @return {?Node} node
   * @template T
   */
  const f = function(node, fn, data) {
    const prevDoc = doc;
    const prevCurrentNode = currentNode;
    const prevCurrentParent = currentParent;
    let previousInAttributes = false;
    let previousInSkip = false;

    doc = node.ownerDocument;
    currentParent = node.parentNode;

    if (__WEBPACK_IMPORTED_MODULE_5__global_js__["a" /* global */].DEBUG) {
      previousInAttributes = Object(__WEBPACK_IMPORTED_MODULE_3__assertions_js__["k" /* setInAttributes */])(false);
      previousInSkip = Object(__WEBPACK_IMPORTED_MODULE_3__assertions_js__["l" /* setInSkip */])(false);
    }

    const focusPath = Object(__WEBPACK_IMPORTED_MODULE_4__dom_util_js__["a" /* getFocusedPath */])(node, currentParent);
    markFocused(focusPath, true);
    const retVal = run(node, fn, data);
    markFocused(focusPath, false);

    if (__WEBPACK_IMPORTED_MODULE_5__global_js__["a" /* global */].DEBUG) {
      Object(__WEBPACK_IMPORTED_MODULE_3__assertions_js__["j" /* assertVirtualAttributesClosed */])();
      Object(__WEBPACK_IMPORTED_MODULE_3__assertions_js__["k" /* setInAttributes */])(previousInAttributes);
      Object(__WEBPACK_IMPORTED_MODULE_3__assertions_js__["l" /* setInSkip */])(previousInSkip);
    }

    doc = prevDoc;
    currentNode = prevCurrentNode;
    currentParent = prevCurrentParent;

    return retVal;
  };
  return f;
};


/**
 * Patches the document starting at node with the provided function. This
 * function may be called during an existing patch operation.
 * @param {!Element|!DocumentFragment} node The Element or Documen to patch.
 * @param {!function(T)} fn A function containing open/close/etc. calls that
 *     describe the DOM.
 * @param {T=} data An argument passed to fn to represent DOM state.
 * @return {!Node} The patched node.
 * @template T
 */
const patchInner = patchFactory(function(node, fn, data) {
  currentNode = node;

  enterNode();
  fn(data);
  exitNode();

  if (__WEBPACK_IMPORTED_MODULE_5__global_js__["a" /* global */].DEBUG) {
    Object(__WEBPACK_IMPORTED_MODULE_3__assertions_js__["e" /* assertNoUnclosedTags */])(currentNode, node);
  }

  return node;
});


/**
 * Patches an Element with the the provided function. Exactly one top level
 * element call should be made corresponding to `node`.
 * @param {!Element} node The Element where the patch should start.
 * @param {!function(T)} fn A function containing open/close/etc. calls that
 *     describe the DOM. This should have at most one top level element call.
 * @param {T=} data An argument passed to fn to represent DOM state.
 * @return {?Node} The node if it was updated, its replacedment or null if it
 *     was removed.
 * @template T
 */
const patchOuter = patchFactory(function(node, fn, data) {
  let startNode = /** @type {!Element} */({ nextSibling: node });
  let expectedNextNode = null;
  let expectedPrevNode = null;

  if (__WEBPACK_IMPORTED_MODULE_5__global_js__["a" /* global */].DEBUG) {
    Object(__WEBPACK_IMPORTED_MODULE_3__assertions_js__["i" /* assertPatchOuterHasParentNode */])(currentParent);
    expectedNextNode = node.nextSibling;
    expectedPrevNode = node.previousSibling;
  }

  currentNode = startNode;
  fn(data);

  if (__WEBPACK_IMPORTED_MODULE_5__global_js__["a" /* global */].DEBUG) {
    Object(__WEBPACK_IMPORTED_MODULE_3__assertions_js__["h" /* assertPatchElementNoExtras */])(startNode, currentNode, expectedNextNode,
        expectedPrevNode);
  }

  if (currentParent) {
    clearUnvisitedDOM(currentParent, getNextNode(), node.nextSibling);
  }

  return (startNode === currentNode) ? null : currentNode;
});


/**
 * Checks whether or not the current node matches the specified nameOrCtor and
 * key.
 *
 * @param {!Node} matchNode A node to match the data to.
 * @param {NameOrCtorDef} nameOrCtor The name or constructor to check for.
 * @param {?string=} key An optional key that identifies a node.
 * @param {*=} typeId An type identifier that avoids reuse between elements that
 *     would otherwise match.
 * @return {boolean} True if the node matches, false otherwise.
 */
const matches = function(matchNode, nameOrCtor, key, typeId) {
  const data = Object(__WEBPACK_IMPORTED_MODULE_2__node_data_js__["a" /* getData */])(matchNode);

  // Key check is done using double equals as we want to treat a null key the
  // same as undefined. This should be okay as the only values allowed are
  // strings, null and undefined so the == semantics are not too weird.
  return nameOrCtor === data.nameOrCtor &&
         typeId === data.typeId &&
         key == data.key;
};


/**
 * Aligns the virtual Node definition with the actual DOM, moving the
 * corresponding DOM node to the correct location or creating it if necessary.
 * @param {NameOrCtorDef} nameOrCtor The name or constructor for the Node.
 * @param {?string=} key The key used to identify the Node..
 * @param {*=} typeId An type identifier that avoids reuse between elements that
 *     would otherwise match.
 */
const alignWithDOM = function(nameOrCtor, key, typeId) {
  if (currentNode && matches(currentNode, nameOrCtor, key, typeId)) {
    return;
  }

  const parentData = Object(__WEBPACK_IMPORTED_MODULE_2__node_data_js__["a" /* getData */])(currentParent);
  const keyMap = parentData.keyMap;
  let node;

  // Check to see if the node has moved within the parent.
  if (key) {
    const keyNode = keyMap[key];
    if (keyNode) {
      if (matches(keyNode, nameOrCtor, key, typeId)) {
        node = keyNode;
      } else {
        // When the keyNode gets removed later, make sure we do not remove the
        // new node from the map.
        Object(__WEBPACK_IMPORTED_MODULE_2__node_data_js__["a" /* getData */])(keyNode).key = null;
      }
    }
  }

  // Create the node if it doesn't exist.
  if (!node) {
    if (nameOrCtor === '#text') {
      node = Object(__WEBPACK_IMPORTED_MODULE_1__nodes_js__["b" /* createText */])(doc);
    } else {
      node = Object(__WEBPACK_IMPORTED_MODULE_1__nodes_js__["a" /* createElement */])(doc, currentParent, nameOrCtor, key, typeId);
    }

    if (key) {
      keyMap[key] = node;
    }
  }

  // Mark element. This is to be able to determine whether
  // this element is fully initiated on creation or if there
  // are still changes coming 
  node.$iDOMCreated = true;

  // Re-order the node into the right position, preserving focus if either
  // node or currentNode are focused by making sure that they are not detached
  // from the DOM.
  if (Object(__WEBPACK_IMPORTED_MODULE_2__node_data_js__["a" /* getData */])(node).focused) {
    // Move everything else before the node.
    Object(__WEBPACK_IMPORTED_MODULE_4__dom_util_js__["b" /* moveBefore */])(currentParent, node, currentNode);
  } else {
    currentParent.insertBefore(node, currentNode);
  }

  currentNode = node;
};


/**
 * Clears out any unvisited Nodes in a given range.
 * @param {?Node} parentNode
 * @param {?Node} startNode The node to start clearing from, inclusive.
 * @param {?Node} endNode The node to clear until, exclusive.
 */
const clearUnvisitedDOM = function(parentNode, startNode, endNode) {
  const data = Object(__WEBPACK_IMPORTED_MODULE_2__node_data_js__["a" /* getData */])(parentNode);
  const keyMap = data.keyMap;
  let child = startNode;

  while (child !== endNode) {
    const next = child.nextSibling;
    const key = Object(__WEBPACK_IMPORTED_MODULE_2__node_data_js__["a" /* getData */])(child).key;
    parentNode.removeChild(child);
    if (key) {
      delete keyMap[key];
    }
    child = next;
  }
};


/**
 * Changes to the first child of the current node.
 */
const enterNode = function() {
  currentParent = currentNode;
  currentNode = null;
};


/**
 * @return {?Node} The next Node to be patched.
 */
const getNextNode = function() {
  if (currentNode) {
    return currentNode.nextSibling;
  } else {
    return currentParent.firstChild;
  }
};


/**
 * Changes to the next sibling of the current node.
 */
const nextNode = function() {
  currentNode = getNextNode();
};


/**
 * Changes to the parent of the current node, removing any unvisited children.
 */
const exitNode = function() {
  if (currentParent && !currentParent.$shadyDom) {
    clearUnvisitedDOM(currentParent, getNextNode(), null);
  }

  currentNode = currentParent;
  currentParent = currentParent.parentNode;
};


/**
 * Makes sure that the current node is an Element with a matching nameOrCtor and
 * key.
 *
 * @param {NameOrCtorDef} nameOrCtor The tag or constructor for the Element.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {*=} typeId An type identifier that avoids reuse between elements that
 *     would otherwise match.
 * @return {!Element} The corresponding Element.
 */
const open = function(nameOrCtor, key, typeId) {
  nextNode();
  alignWithDOM(nameOrCtor, key, typeId);
  enterNode();
  return /** @type {!Element} */(currentParent);
};


/**
 * Closes the currently open Element, removing any unvisited children if
 * necessary.
 *
 * @return {!Element} The corresponding Element.
 */
const close = function() {
  if (__WEBPACK_IMPORTED_MODULE_5__global_js__["a" /* global */].DEBUG) {
    Object(__WEBPACK_IMPORTED_MODULE_3__assertions_js__["l" /* setInSkip */])(false);
  }

  exitNode();
  return /** @type {!Element} */(currentNode);
};


/**
 * Makes sure the current node is a Text node and creates a Text node if it is
 * not.
 *
 * @return {!Text} The corresponding Text Node.
 */
const text = function() {
  nextNode();
  alignWithDOM('#text', null);
  return /** @type {!Text} */(currentNode);
};


/**
 * Gets the current Element being patched.
 * @return {!Element}
 */
const currentElement = function() {
  if (__WEBPACK_IMPORTED_MODULE_5__global_js__["a" /* global */].DEBUG) {
    Object(__WEBPACK_IMPORTED_MODULE_3__assertions_js__["c" /* assertInPatch */])('currentElement', doc);
    Object(__WEBPACK_IMPORTED_MODULE_3__assertions_js__["f" /* assertNotInAttributes */])('currentElement');
  }
  return /** @type {!Element} */(currentParent);
};


/**
 * @return {Node} The Node that will be evaluated for the next instruction.
 */
const currentPointer = function() {
  if (__WEBPACK_IMPORTED_MODULE_5__global_js__["a" /* global */].DEBUG) {
    Object(__WEBPACK_IMPORTED_MODULE_3__assertions_js__["c" /* assertInPatch */])('currentPointer', doc);
    Object(__WEBPACK_IMPORTED_MODULE_3__assertions_js__["f" /* assertNotInAttributes */])('currentPointer');
  }
  return getNextNode();
};


/**
 * Skips the children in a subtree, allowing an Element to be closed without
 * clearing out the children.
 */
const skip = function() {
  if (__WEBPACK_IMPORTED_MODULE_5__global_js__["a" /* global */].DEBUG) {
    Object(__WEBPACK_IMPORTED_MODULE_3__assertions_js__["d" /* assertNoChildrenDeclaredYet */])('skip', currentNode);
    Object(__WEBPACK_IMPORTED_MODULE_3__assertions_js__["l" /* setInSkip */])(true);
  }
  currentNode = currentParent.lastChild;
};


/**
 * Skips the next Node to be patched, moving the pointer forward to the next
 * sibling of the current pointer.
 */
const skipNode = nextNode;


/** */



/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return assertInPatch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return assertNoUnclosedTags; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return assertNotInAttributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return assertInAttributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return assertCloseMatchesOpenTag; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return assertVirtualAttributesClosed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return assertNoChildrenDeclaredYet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return assertNotInSkip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return assertPatchElementNoExtras; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return assertPatchOuterHasParentNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return setInAttributes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return setInSkip; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__types_js__ = __webpack_require__(0);
/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */




/**
  * Keeps track whether or not we are in an attributes declaration (after
  * elementOpenStart, but before elementOpenEnd).
  * @type {boolean}
  */
let inAttributes = false;


/**
  * Keeps track whether or not we are in an element that should not have its
  * children cleared.
  * @type {boolean}
  */
let inSkip = false;


/**
 * Makes sure that there is a current patch context.
 * @param {string} functionName
 * @param {*} context
 */
const assertInPatch = function(functionName, context) {
  if (!context) {
    throw new Error('Cannot call ' + functionName + '() unless in patch.');
  }
};


/**
 * Makes sure that a patch closes every node that it opened.
 * @param {?Node} openElement
 * @param {!Node|!DocumentFragment} root
 */
const assertNoUnclosedTags = function(openElement, root) {
  if (openElement === root) {
    return;
  }

  let currentElement = openElement;
  const openTags = [];
  while (currentElement && currentElement !== root) {
    openTags.push(currentElement.nodeName.toLowerCase());
    currentElement = currentElement.parentNode;
  }

  throw new Error('One or more tags were not closed:\n' +
      openTags.join('\n'));
};


/**
 * Makes sure that node being outer patched has a parent node.
 * @param {?Node} parent
 */
const assertPatchOuterHasParentNode = function(parent) {
  if (!parent) {
    throw new Error('patchOuter requires the node have a parent.');
  }
};


/**
 * Makes sure that the caller is not where attributes are expected.
 * @param {string} functionName
 */
const assertNotInAttributes = function(functionName) {
  if (inAttributes) {
    throw new Error(functionName + '() can not be called between ' +
        'elementOpenStart() and elementOpenEnd().');
  }
};


/**
 * Makes sure that the caller is not inside an element that has declared skip.
 * @param {string} functionName
 */
const assertNotInSkip = function(functionName) {
  if (inSkip) {
    throw new Error(functionName + '() may not be called inside an element ' +
        'that has called skip().');
  }
};


/**
 * Makes sure that the caller is where attributes are expected.
 * @param {string} functionName
 */
const assertInAttributes = function(functionName) {
  if (!inAttributes) {
    throw new Error(functionName + '() can only be called after calling ' +
        'elementOpenStart().');
  }
};


/**
 * Makes sure the patch closes virtual attributes call
 */
const assertVirtualAttributesClosed = function() {
  if (inAttributes) {
    throw new Error('elementOpenEnd() must be called after calling ' +
        'elementOpenStart().');
  }
};


/**
  * Makes sure that tags are correctly nested.
  * @param {NameOrCtorDef} currentNameOrCtor
  * @param {NameOrCtorDef} nameOrCtor
  */
const assertCloseMatchesOpenTag = function(currentNameOrCtor, nameOrCtor) {
  if (currentNameOrCtor !== nameOrCtor) {
    throw new Error('Received a call to close "' + nameOrCtor + '" but "' +
        currentNameOrCtor + '" was open.');
  }
};


/**
 * Makes sure that no children elements have been declared yet in the current
 * element.
 * @param {string} functionName
 * @param {?Node} previousNode
 */
const assertNoChildrenDeclaredYet = function(functionName, previousNode) {
  if (previousNode !== null) {
    throw new Error(functionName + '() must come before any child ' +
        'declarations inside the current element.');
  }
};


/**
 * Checks that a call to patchOuter actually patched the element.
 * @param {?Node} startNode The value for the currentNode when the patch
 *     started.
 * @param {?Node} currentNode The currentNode when the patch finished.
 * @param {?Node} expectedNextNode The Node that is expected to follow the
 *    currentNode after the patch;
 * @param {?Node} expectedPrevNode The Node that is expected to preceed the
 *    currentNode after the patch.
 */
const assertPatchElementNoExtras = function(
    startNode,
    currentNode,
    expectedNextNode,
    expectedPrevNode) {
  const wasUpdated = currentNode.nextSibling === expectedNextNode &&
                     currentNode.previousSibling === expectedPrevNode;
  const wasChanged = currentNode.nextSibling === startNode.nextSibling &&
                     currentNode.previousSibling === expectedPrevNode;
  const wasRemoved = currentNode === startNode;

  if (!wasUpdated && !wasChanged && !wasRemoved) {
    throw new Error('There must be exactly one top level call corresponding ' +
        'to the patched element.');
  }
};


/**
 * Updates the state of being in an attribute declaration.
 * @param {boolean} value
 * @return {boolean} the previous value.
 */
const setInAttributes = function(value) {
  const previous = inAttributes;
  inAttributes = value;
  return previous;
};


/**
 * Updates the state of being in a skip element.
 * @param {boolean} value
 * @return {boolean} the previous value.
 */
const setInSkip = function(value) {
  const previous = inSkip;
  inSkip = value;
  return previous;
};


/** */



/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return global; });
/**
 * Copyright 2017 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const global = typeof self !== 'undefined' ? self :
    typeof window !== 'undefined' ?  window :
    typeof global !== 'undefined' ?  global :
    {};




/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return updateAttribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return applyProp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return applyAttr; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return attributes; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__symbols_js__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__util_js__ = __webpack_require__(2);
/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * @param {string} name
 * @return {string|undefined} The namespace to use for the attribute.
 */
const getNamespace = function(name) {
  if (name.lastIndexOf('xml:', 0) === 0) {
    return 'http://www.w3.org/XML/1998/namespace';
  }

  if (name.lastIndexOf('xlink:', 0) === 0) {
    return 'http://www.w3.org/1999/xlink';
  }
};


/**
 * Applies an attribute or property to a given Element. If the value is null
 * or undefined, it is removed from the Element. Otherwise, the value is set
 * as an attribute.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {?(boolean|number|string)=} value The attribute's value.
 */
const applyAttr = function(el, name, value) {
  if (value == null) {
    el.removeAttribute(name);
  } else {
    const attrNS = getNamespace(name);
    if (attrNS) {
      el.setAttributeNS(attrNS, name, value);
    } else {
      el.setAttribute(name, value);
    }
  }
};

/**
 * Applies a property to a given Element.
 * @param {!Element} el
 * @param {string} name The property's name.
 * @param {*} value The property's value.
 */
const applyProp = function(el, name, value) {
  el[name] = value;
};


/**
 * Applies a value to a style declaration. Supports CSS custom properties by
 * setting properties containing a dash using CSSStyleDeclaration.setProperty.
 * @param {CSSStyleDeclaration} style
 * @param {string} prop
 * @param {string} value
 */
const setStyleValue = function(style, prop, value) {
  if (prop.indexOf('-') >= 0) {
    style.setProperty(prop, value);
  } else {
    style[prop] = value;
  }
};


/**
 * Applies a style to an Element. No vendor prefix expansion is done for
 * property names/values.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} style The style to set. Either a string of css or an object
 *     containing property-value pairs.
 */
const applyStyle = function(el, name, style) {
  if (typeof style === 'string') {
    el.style.cssText = style;
  } else {
    el.style.cssText = '';
    const elStyle = el.style;
    const obj = /** @type {!Object<string,string>} */(style);

    for (const prop in obj) {
      if (Object(__WEBPACK_IMPORTED_MODULE_1__util_js__["b" /* has */])(obj, prop)) {
        setStyleValue(elStyle, prop, obj[prop]);
      }
    }
  }
};


/**
 * Updates a single attribute on an Element.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value. If the value is an object or
 *     function it is set on the Element, otherwise, it is set as an HTML
 *     attribute.
 */
const applyAttributeTyped = function(el, name, value) {
  const type = typeof value;

  if (type === 'object' || type === 'function') {
    applyProp(el, name, value);
  } else {
    applyAttr(el, name, /** @type {?(boolean|number|string)} */(value));
  }
};


/**
 * Calls the appropriate attribute mutator for this attribute.
 * @param {!Element} el
 * @param {string} name The attribute's name.
 * @param {*} value The attribute's value.
 */
const updateAttribute = function(el, name, value) {
  const mutator = attributes[name] || attributes[__WEBPACK_IMPORTED_MODULE_0__symbols_js__["a" /* symbols */].default];
  mutator(el, name, value);
};


/**
 * A publicly mutable object to provide custom mutators for attributes.
 * @const {!Object<string, function(!Element, string, *)>}
 */
const attributes = Object(__WEBPACK_IMPORTED_MODULE_1__util_js__["a" /* createMap */])();

// Special generic mutator that's called for any attribute that does not
// have a specific mutator.
attributes[__WEBPACK_IMPORTED_MODULE_0__symbols_js__["a" /* symbols */].default] = applyAttributeTyped;

attributes['style'] = applyStyle;


/** */



/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return symbols; });
/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** @const */
const symbols = {
  default: '__default'
};

/** */



/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {module.exports = global["Simply"] = __webpack_require__(10);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9)))

/***/ }),
/* 9 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

const iDOM = __webpack_require__(11);

// enforce { prop } formated attribute values
// to set the property instead of the attribute
iDOM.attributes[iDOM.symbols.default] = (element, name, value) => {
    if(name.includes('{')){
        return iDOM.applyProp(element, snakeToCamel(name.replace('{', '').replace('}', '')), value);
    }else{
        return iDOM.applyAttr(element, name, value);
    }
};

const registeredComponents = new Map();
// default settings
const settings = {
    showCompilationWarnings: false
};

/**
 * @param template
 * @constructor
 */
function SimplyRender(template){

    // no need for a "data" component, since we
    // assume that it will be attached to the node
    // but we add it as an optional for the cases where
    // the node needs data from a parent component for eaxample
    // in a forEach

    // 1. Parse the template into a DOM node
    // that we can parse for attributes
    const fragment = document.createDocumentFragment();
    const div = document.createElement('div');
    fragment.appendChild(div);
    div.innerHTML = preProcessTemplate(template);
    const dom = div;
    let iTemplate = generateTemplateFromNodes([...dom.childNodes]);

    // 3. Convert and return the string as a function

    return (thisNode, renderNode) => {

        if(!renderNode){
            renderNode = thisNode;
        }
        // this timeout is needed to queue up the contents
        // in the next javascript frame. This is necessary
        // to not trigger two nested patch operations.
        //
        // Nested patches will happen when the creation of a
        // new element triggers connectedCallback - which in turn
        // triggers a render. This all happens in one frame and
        // confuses the incremental-dom library.
        // so we use setTimeout to queue up the function for the
        // next frame.

        iDOM.patch(renderNode, () => {
            new Function('node', 'iDOM', 'settings', `
                ${iTemplate}
            `).call(thisNode, thisNode, iDOM, settings);
        });

    }

    // Notes on performance: if this walk becomes a nusance when
    // attached to custom component creation we could have all
    // the components compiled at startup - and then eventually
    // in a buildstep. Cross this bridge when you come to it

}

function generateTemplateFromNodes(templateNodes){
    return templateNodes.map((curTemplateNode) => {
        return generateTemplateRecusive(curTemplateNode);
    }).join('\n')
}

function generateTemplateRecusive(curNode){

    // accessible variables in the written functions
    // are `curNode and `node`

    // we wrap a iife to make sure the curNode
    // is accessible in the right scope for the
    // attrProps
    let iTemplate = `
        (function(){
            let curNode = null;
    `;
    const nodeType = curNode.nodeType;

    if(nodeType === HTMLElement.TEXT_NODE){

        // a text node is simple, no attributes
        // and no children. We can exit here
        iTemplate += addText(curNode.nodeValue);

    }else if(nodeType === HTMLElement.ELEMENT_NODE){

        // 2 Examine the attributes
        const tagName = curNode.tagName.toLowerCase();
        const attrProps = parseAttrProps(curNode.attributes);

        // if the node has an each attribute we need to
        // stamp that whole element according to its each
        // properties.
        if(attrProps.each){
            iTemplate += applyEach(attrProps.each, curNode);
        }else{
            if(attrProps.if) iTemplate += openIfStatement(attrProps.if);

            // 3 Open tag
            // if there is an if attrProp we wrap this
            // in an if statement
            // TODO: Void elements
            iTemplate += openTag(tagName, attrProps.staticAttributes);

            // 4 Apply the attributes
            iTemplate += applyAttributes(curNode.attributes, attrProps);

            // 5 Close open tag
            // curNode is now available in the written function
            iTemplate += closeOpenTag();

            // 4 Render children if applicable
            curNode.childNodes.forEach((childNode) => {
                iTemplate += generateTemplateRecusive(childNode);
            });

            // 5 Apply attribute properties
            iTemplate += applyAttrProps(attrProps, curNode);

            // 6 Close the tag
            iTemplate += closeElement(tagName);

            iTemplate += triggerCompiled();

            if(attrProps.if) iTemplate += closeIfStatement();
        }
    }

    iTemplate += `
        }).call(node);
    `;

    return iTemplate;

}

/**
 * When we're finished compiling an element we trigger a compiled
 * event to let the element initiate itself.
 *
 * Why not rely on the connectedCallback for this? Because the that
 * callback triggers on first connection with the DOM which is before
 * having had its attributes and attrProps assigned.
 */
function triggerCompiled(){
    return `
        if(curNode.$compiled != true){
            if(curNode.compiledCallback)
                curNode.compiledCallback();
                
            curNode.$compiled = true;
        }
    `;
}

function closeElement(tagName){
    return `
    iDOM.elementClose('${tagName}');
`
}

function openIfStatement(condition){

    // if a condition throws an error its false
    return `
        let condition;
        try{
            condition = ${condition}
        }catch(err){
            ${function () {
                if (settings.showCompilationWarnings) {
                    return `console.warn(err);`;
                }
            }()}
            condition = false;
        }
        if (condition) {
    `;
}

function closeIfStatement() {
    return `
    }
`;
}

function closeOpenTag() {

    // if the DOM element is being reused
    // from a previous one we need to clean the listeners
    // off.

    // check id of the DOM element
    // if separate
    return `
    curNode = iDOM.elementOpenEnd();
`;
}

function applyEach(each, curNode){
    const [item, collection] = each.split(' in ');
    let tmpl = '';

    // clean curNode from the each property before we start
    // stamping it - otherwise this will lead to an infinite loop
    curNode.removeAttribute('each');

    // TODO: There is a bug where where events set on an element
    // inside an each statement will have the data object set as
    // "this". 
    tmpl += wrapAndThrowError(`
        // generate repeating element
        ${collection}.forEach((${item}) => {
            ${generateTemplateRecusive(curNode)}
        });
    `);

    return tmpl;
}

function wrapAndThrowError(codeString){
    return `
        try{
            ${codeString}
        }catch(err){
            ${function () {
                if (settings.showCompilationWarnings) {
                    return `console.warn(err);`;
                }
            }()}
        }
    `;
}

function applyAttrProps(attrProps, curNode){
    let tmpl = '';
    if(attrProps.ref){
        tmpl += `
        if(!node.$) node.$ = {};
        node.$['${snakeToCamel(attrProps.ref)}'] = curNode;
    `;
    }

    // iDom likes to re-use dom elements instead of creating new ones
    // but this means that we have to clean up our own event listeners
    // else the listener from a previous object will be attached to
    // a newer (but reused) one.
    tmpl += `
        if(curNode.listeners && curNode.listeners.size > 0){
            curNode.listeners.forEach((callback, eventName) => {
                curNode.removeEventListener(eventName, callback)
            })
            curNode.listeners = new Map();
        }  
    `;

    if(attrProps.listeners.length > 0) {
        tmpl += `
            curNode.listeners = curNode.listeners || new Map();
        `;

        tmpl += attrProps.listeners.map((listener) => {
            return `
            if(!curNode.listeners.has('${listener.eventName}')){
                const listener = (e) => {
                    const $event = e;
                    const $evt = e;
                    const $element = curNode;
                    const $el = curNode;
                    ${listener.callback};
                };
                curNode.addEventListener('${listener.eventName}', listener);
                curNode.listeners.set('${listener.eventName}', listener);
            }
        `;
        }).join('\n ');
    }

    return tmpl;
}

function parseAttrProps(attrs, curNode){

    const attrProps = {
        listeners: [], // the event name and js string to evaluate
        ref: null, // the name of the ref
        if: null, // the condition in js
        show: null, // the condition in js
        each: null, // the formula and template
        staticAttributes: [] // list of normal attributes
    };
    [...attrs].forEach((attr) => {
        const attrName = attr.name;
        const attrValue = attr.value.trim();

        if (isEventAttr(attrName)) {
            const eventName = getEventName(attrName);
            attrProps.listeners.push({eventName, callback: attrValue});

        } else if (isRefAttr(attrName)) {
            attrProps.ref = getRefName(attrName);

        } else if (isEachAttr(attrName)) {
            attrProps.each = attrValue;

        } else if (isIfAttr(attrName)) {
            attrProps.if = attrValue;

        } else if (isShowAttr(attrName)) {
            attrProps.show = attrValue;
        } else {
            // If the attribute is a simple non iterpolatable
            // value we add it to the static array. This way
            // it can be applied immediately when we create the
            // DOM object - and will be present in the
            // connectionCallback call.
            if(!shouldInterpolateString(attrValue)){
                attrProps.staticAttributes.push({name: attrName, value: attrValue});
            }
        }
    });
    return attrProps;
}

function isShowAttr(attrName){
    return attrName === 'show';
}

function isIfAttr(attrName){
    return attrName === 'if';
}

function isEventAttr(attrName){
    return attrName.match(/^\(.+\)$/)
}

function getEventName(attrName){
    return attrName.replace(/[()]/g, '');
}

function isRefAttr(attrName){
    return attrName.match(/^#/);
}

function isEachAttr(attrName){
    return attrName === 'each';
}

function getRefName(attrName){
    return attrName.replace(/^#/, '');
}

function applyAttributes(attrs, attrProps){
    let tmpl = [...attrs].map(attr => {
        let attrValue = attr.value;
        let tmpl;
        if(shouldInterpolate(attrValue)){
            attrValue = cleanInterpolationTags(attrValue);
            tmpl = wrapAndThrowError(`
            iDOM.attr('${cleanAttrName(attr.name)}', ${attrValue});
        `);
        }else{
            tmpl = `
            iDOM.attr('${cleanAttrName(attr.name)}', '${escapeSingleQuotes(attrValue)}');
        `;
        }

        return tmpl;
    }).join('\n');

    // inject a show attribute toggle
    // if we have a show attribute property
    if(attrProps.show){
        tmpl += `
            iDOM.attr('style', !!${attrProps.show} ? '' : 'display: none;');
        `;
    }

    return tmpl;
}

/**
 * @param {String} tagName
 * @param {Array<{name: String, value: Mixed}>} staticAttrProps
 * @returns {string}
 */
function openTag(tagName, staticAttrProps){

    const props = staticAttrProps || [];
    const propsArray = props.reduce((prev, prop) => {
        return [...prev, prop.name, prop.value];
    }, []);
    const attributesString = JSON.stringify(propsArray);

    return `
        iDOM.elementOpenStart('${tagName}', '', ${attributesString});
    `
}

function addText(textValue){
    let text = textValue.trim();
    let tmpl = '';

    if(shouldInterpolateString(text)){

        // convert from {{ javascript }} => ${javascript}
        text = convertToTemplateVars(text);

        // it is possible that we get null pointers
        // anytime we are interpolating values
        // so we should capture those
        tmpl += wrapAndThrowError(`
            iDOM.text(\`${text}\`);
        `);

    }else{
        tmpl += `
            iDOM.text(\`${escapeBacktickQuotes(text)}\`);
        `;
    }

    return tmpl;
}

function cleanAttrName(attrName){
    if(isEventAttr(attrName)){
        return 'event-' + getEventName(attrName);
    }else if(isRefAttr(attrName)){
        return 'ref-' + getRefName(attrName);
    }else{
        return attrName;
    }
}

/**
 * Does the string include { } characters?
 * @param stringValue
 */
function shouldInterpolate(stringValue){
    return stringValue.match(/^{.+}$/);
}

function shouldInterpolateString(stringValue){
    return stringValue.match(/{{([\s\S]*?)}}/);
}

function cleanInterpolationTags(text){
    return text.replace(/[{}]/g, '');
}

function escapeSingleQuotes(text){
    return text.replace(/'/g, "\\'");
}

function escapeBacktickQuotes(text){
    return text.replace(/`/g, "\\`");
}

function getStringInterpolationValue(text){

    // match anything between {{ and }}
    return text.replace(/{{([\s\S]*?)}}/g, (match) => {
        // remove the interpolation indicators
        const js = match.replace(/{{|}}/g, '');
        return '${' + js + '}';
    });
}

function convertToTemplateVars(text){

    // match anything between {{ and }}
    return text.replace(/{{([\s\S]*?)}}/g, (match) => {
        // remove the interpolation indicators
        const js = match.replace(/{{|}}/g, '');

        // this prevents us from rendering undeclared
        // vars as an "undefined" string
        return '${' + js + ' === undefined ? "" : ' + js + '}';
    });
}

function snakeToCamel(str){
    return str.replace(/-([a-z])/g, function (g) { return g[1].toUpperCase(); });
}

function camelToSnake(str){
    return str.replace(/([A-Z])/g, function($1){return "-"+$1.toLowerCase();});
}

function preProcessTemplate(template){

    // replace id refs with kebab-cased
    // <div #someId> -> <div #some-id
    return template.replace(/<([\s\S]+?)>/g, (matchTag) => {
        return matchTag.replace(/#([a-zA-Z]+?)[> ]/, (match) => {
            return camelToSnake(match)
        })
    })
}

class Component extends HTMLElement{

    static compile(){
        const render = SimplyRender(this.template);
        this.prototype.$shadyDom = this.shadyDom
        this.prototype.render = function () {

            // shadyDom means we render directly to the components innerHTML
            // this circumvents iDOM compilation of children
            return render(this, this.$shadyDom ? this : this.shadow);
        }

        // wraps the given property in a setter to render
        // on update
        if(this.props){
            this.props.forEach((prop) => {

                // TODO: throw error if the property already exists
                Object.defineProperty(this.prototype, prop, {
                    set: function (value) {
                        this['_'+prop] = value;
                        this.render();
                    },
                    get: function () {
                        return this['_'+prop];
                    }
                })
            })
        }

        // save user defined callback to schedule
        // connectedCallback AFTER compile to ensure
        // we have all state set before we start manipulation
        const userDefinedCallback = this.prototype.connectedCallback;

        // connectedCallback triggers rendering routine
        this.prototype.connectedCallback = function(){

            // In the case of this method being called inside of a simply template
            // we want to wait till the compiled handler to trigger this logic

            // BUT in the case of the simply component being added directly to
            // the the DOM and not via a simply template we want to trigger it directly

            // When an element is created via iDOM - it puts this flag on the node.
            // If so - we wait to trigger the connectedCallback till all compilation
            // is done.
            if(!this.$iDOMCreated){
                if(userDefinedCallback)
                    userDefinedCallback.call(this);

                this.render();
            }
        }

        // rendering routine triggers compiled callback
        this.prototype.compiledCallback = function () {

            if(userDefinedCallback)
                userDefinedCallback.call(this);

            // We render again to pickup the compiled values
            // TODO: This could be refactored for efficiency
            this.render();
        }
    }

    static define(tagName){
        if(registeredComponents.has(tagName)){
            throw new Error('You\'re trying to define ' + tagName + ' twice');
            return;
        }
        this.compile();
        customElements.define(tagName, this);
        registeredComponents.set(tagName, this);
    }

    constructor(){
        super();
        if(!this.$shadyDom)
            this.shadow = this.attachShadow({mode: 'open'});
    }

    static get template(){
        throw Error('Template methods needs to be overriden by compoent');
    }
}

module.exports = {
    settings,
    define: function(tagName, classDefinition){
        classDefinition.compile();
        customElements.define(tagName, classDefinition);
    },
    compileTemplate: SimplyRender,
    iDOM,
    Component: Component,
    preProcessTemplate
};



/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__src_core_js__ = __webpack_require__(3);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "patch", function() { return __WEBPACK_IMPORTED_MODULE_0__src_core_js__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "patchInner", function() { return __WEBPACK_IMPORTED_MODULE_0__src_core_js__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "patchOuter", function() { return __WEBPACK_IMPORTED_MODULE_0__src_core_js__["f"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "open", function() { return __WEBPACK_IMPORTED_MODULE_0__src_core_js__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "close", function() { return __WEBPACK_IMPORTED_MODULE_0__src_core_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "currentElement", function() { return __WEBPACK_IMPORTED_MODULE_0__src_core_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "currentPointer", function() { return __WEBPACK_IMPORTED_MODULE_0__src_core_js__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "skip", function() { return __WEBPACK_IMPORTED_MODULE_0__src_core_js__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "skipNode", function() { return __WEBPACK_IMPORTED_MODULE_0__src_core_js__["h"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__src_virtual_elements_js__ = __webpack_require__(14);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "elementVoid", function() { return __WEBPACK_IMPORTED_MODULE_1__src_virtual_elements_js__["f"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "elementOpenStart", function() { return __WEBPACK_IMPORTED_MODULE_1__src_virtual_elements_js__["e"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "elementOpenEnd", function() { return __WEBPACK_IMPORTED_MODULE_1__src_virtual_elements_js__["d"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "elementOpen", function() { return __WEBPACK_IMPORTED_MODULE_1__src_virtual_elements_js__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "elementClose", function() { return __WEBPACK_IMPORTED_MODULE_1__src_virtual_elements_js__["b"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "text", function() { return __WEBPACK_IMPORTED_MODULE_1__src_virtual_elements_js__["g"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "attr", function() { return __WEBPACK_IMPORTED_MODULE_1__src_virtual_elements_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__src_symbols_js__ = __webpack_require__(7);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "symbols", function() { return __WEBPACK_IMPORTED_MODULE_2__src_symbols_js__["a"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__src_attributes_js__ = __webpack_require__(6);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "attributes", function() { return __WEBPACK_IMPORTED_MODULE_3__src_attributes_js__["c"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "applyAttr", function() { return __WEBPACK_IMPORTED_MODULE_3__src_attributes_js__["a"]; });
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "applyProp", function() { return __WEBPACK_IMPORTED_MODULE_3__src_attributes_js__["b"]; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__src_node_data_js__ = __webpack_require__(1);
/* harmony reexport (binding) */ __webpack_require__.d(__webpack_exports__, "importNode", function() { return __WEBPACK_IMPORTED_MODULE_4__src_node_data_js__["b"]; });
/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */








/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return createElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return createText; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__types_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__node_data_js__ = __webpack_require__(1);
/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */





/**
 * Gets the namespace to create an element (of a given tag) in.
 * @param {string} tag The tag to get the namespace for.
 * @param {?Node} parent
 * @return {?string} The namespace to create the tag in.
 */
const getNamespaceForTag = function(tag, parent) {
  if (tag === 'svg') {
    return 'http://www.w3.org/2000/svg';
  }

  if (Object(__WEBPACK_IMPORTED_MODULE_1__node_data_js__["a" /* getData */])(parent).nameOrCtor === 'foreignObject') {
    return null;
  }

  return parent.namespaceURI;
};


/**
 * Creates an Element.
 * @param {Document} doc The document with which to create the Element.
 * @param {?Node} parent
 * @param {NameOrCtorDef} nameOrCtor The tag or constructor for the Element.
 * @param {?string=} key A key to identify the Element.
 * @param {*=} typeId The type identifier for the Element.
 * @return {!Element}
 */
const createElement = function(doc, parent, nameOrCtor, key, typeId) {
  let el;

  if (typeof nameOrCtor === 'function') {
    el = new nameOrCtor();
  } else {
    const namespace = getNamespaceForTag(nameOrCtor, parent);

    if (namespace) {
      el = doc.createElementNS(namespace, nameOrCtor);
    } else {
      el = doc.createElement(nameOrCtor);
    }
  }

  Object(__WEBPACK_IMPORTED_MODULE_1__node_data_js__["c" /* initData */])(el, nameOrCtor, key, typeId);

  return el;
};


/**
 * Creates a Text Node.
 * @param {Document} doc The document with which to create the Element.
 * @return {!Text}
 */
const createText = function(doc) {
  const node = doc.createTextNode('');
  Object(__WEBPACK_IMPORTED_MODULE_1__node_data_js__["c" /* initData */])(node, '#text', null);
  return node;
};


/** */



/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return getFocusedPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return moveBefore; });
/**
 * Copyright 2016 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * @param {!Node} node
 * @return {boolean} True if the node the root of a document, false otherwise.
 */
const isDocumentRoot = function(node) {
  return node.nodeType === 11 || node.nodeType === 9;
};


/**
 * @param {!Node} node The node to start at, inclusive.
 * @param {?Node} root The root ancestor to get until, exclusive.
 * @return {!Array<!Node>} The ancestry of DOM nodes.
 */
const getAncestry = function(node, root) {
  const ancestry = [];
  let cur = node;

  while (cur !== root) {
    ancestry.push(cur);
    cur = cur.parentNode;
  }

  return ancestry;
};


/**
 * @return {!Node} The root node of the DOM tree that contains this node.
 * @this Node
 */
const getRootNode = Node.prototype.getRootNode || function() {
  let cur = this;
  let prev = cur;

  while (cur) {
    prev = cur;
    cur = cur.parentNode;
  }

  return prev;
};


/**
 * @param {!Node} node The node to get the activeElement for.
 * @return {?Element} The activeElement in the Document or ShadowRoot
 *     corresponding to node, if present.
 */
const getActiveElement = function(node) {
  const root = getRootNode.call(node);
  return isDocumentRoot(root) ? root.activeElement : null;
};


/**
 * Gets the path of nodes that contain the focused node in the same document as
 * a reference node, up until the root.
 * @param {!Node} node The reference node to get the activeElement for.
 * @param {?Node} root The root to get the focused path until.
 * @return {!Array<Node>}
 */
const getFocusedPath = function(node, root) {
  const activeElement = getActiveElement(node);

  if (!activeElement || !node.contains(activeElement)) {
    return [];
  }

  return getAncestry(activeElement, root);
};


/**
 * Like insertBefore, but instead instead of moving the desired node, instead
 * moves all the other nodes after.
 * @param {?Node} parentNode
 * @param {!Node} node
 * @param {?Node} referenceNode
 */
const moveBefore = function(parentNode, node, referenceNode) {
  const insertReferenceNode = node.nextSibling;
  let cur = referenceNode;

  while (cur !== node) {
    const next = cur.nextSibling;
    parentNode.insertBefore(cur, insertReferenceNode);
    cur = next;
  }
};


/** */




/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return elementOpenStart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return elementOpenEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return elementOpen; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return elementVoid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return elementClose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return text; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return attr; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__types_js__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__core_js__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__attributes_js__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__node_data_js__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__assertions_js__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__util_js__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__global_js__ = __webpack_require__(5);
/**
 * Copyright 2015 The Incremental DOM Authors. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS-IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */










/**
 * The offset in the virtual element declaration where the attributes are
 * specified.
 * @const
 */
const ATTRIBUTES_OFFSET = 3;


/**
 * Builds an array of arguments for use with elementOpenStart, attr and
 * elementOpenEnd.
 * @const {!Array<*>}
 */
const argsBuilder = [];


/**
 * Used to keep track of the previous values when a 2-way diff is necessary.
 * This object is reused.
 * @const {Object<*>}
 */
const prevAttrsMap = Object(__WEBPACK_IMPORTED_MODULE_5__util_js__["a" /* createMap */])();


/**
 * @param {NameOrCtorDef} nameOrCtor The Element's tag or constructor.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args, Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {!Element} The corresponding Element.
 */
const elementOpen = function(nameOrCtor, key, statics, var_args) {
  if (__WEBPACK_IMPORTED_MODULE_6__global_js__["a" /* global */].DEBUG) {
    Object(__WEBPACK_IMPORTED_MODULE_4__assertions_js__["f" /* assertNotInAttributes */])('elementOpen');
    Object(__WEBPACK_IMPORTED_MODULE_4__assertions_js__["g" /* assertNotInSkip */])('elementOpen');
  }

  const node = Object(__WEBPACK_IMPORTED_MODULE_1__core_js__["d" /* open */])(nameOrCtor, key);
  const data = Object(__WEBPACK_IMPORTED_MODULE_3__node_data_js__["a" /* getData */])(node);

  if (!data.staticsApplied) {
    if (statics) {
      for (let i = 0; i < statics.length; i += 2) {
        const name = /** @type {string} */(statics[i]);
        const value = statics[i + 1];
        Object(__WEBPACK_IMPORTED_MODULE_2__attributes_js__["d" /* updateAttribute */])(node, name, value);
      }
    }
    // Down the road, we may want to keep track of the statics array to use it
    // as an additional signal about whether a node matches or not. For now,
    // just use a marker so that we do not reapply statics.
    data.staticsApplied = true;
  }

  /*
   * Checks to see if one or more attributes have changed for a given Element.
   * When no attributes have changed, this is much faster than checking each
   * individual argument. When attributes have changed, the overhead of this is
   * minimal.
   */
  const attrsArr = data.attrsArr;
  const isNew = !attrsArr.length;
  let i = ATTRIBUTES_OFFSET;
  let j = 0;

  for (; i < arguments.length; i += 2, j += 2) {
    const name = arguments[i];
    if (isNew) {
      attrsArr[j] = name;
    } else if (attrsArr[j] !== name) {
      break;
    }

    const value = arguments[i + 1];
    if (isNew || attrsArr[j + 1] !== value) {
      attrsArr[j + 1] = value;
      Object(__WEBPACK_IMPORTED_MODULE_2__attributes_js__["d" /* updateAttribute */])(node, name, value);
    }
  }

  /*
   * Items did not line up exactly as before, need to make sure old items are
   * removed. This can happen if using conditional logic when declaring
   * attrs through the elementOpenStart flow or if one element is reused in
   * the place of another.
   */
  if (i < arguments.length || j < attrsArr.length) {
    const attrsStart = j;

    for (; j < attrsArr.length; j += 2) {
      prevAttrsMap[attrsArr[j]] = attrsArr[j + 1];
    }

    for (j = attrsStart; i < arguments.length; i += 2, j += 2) {
      const name = arguments[i];
      const value = arguments[i + 1];

      if (prevAttrsMap[name] !== value) {
        Object(__WEBPACK_IMPORTED_MODULE_2__attributes_js__["d" /* updateAttribute */])(node, name, value);
      }

      attrsArr[j] = name;
      attrsArr[j + 1] = value;

      delete prevAttrsMap[name];
    }

    Object(__WEBPACK_IMPORTED_MODULE_5__util_js__["c" /* truncateArray */])(attrsArr, j);

    /*
     * At this point, only have attributes that were present before, but have
     * been removed.
     */
    for (const name in prevAttrsMap) {
      Object(__WEBPACK_IMPORTED_MODULE_2__attributes_js__["d" /* updateAttribute */])(node, name, undefined);
      delete prevAttrsMap[name];
    }
  }

  return node;
};


/**
 * Declares a virtual Element at the current location in the document. This
 * corresponds to an opening tag and a elementClose tag is required. This is
 * like elementOpen, but the attributes are defined using the attr function
 * rather than being passed as arguments. Must be folllowed by 0 or more calls
 * to attr, then a call to elementOpenEnd.
 * @param {NameOrCtorDef} nameOrCtor The Element's tag or constructor.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 */
const elementOpenStart = function(nameOrCtor, key, statics) {
  if (__WEBPACK_IMPORTED_MODULE_6__global_js__["a" /* global */].DEBUG) {
    Object(__WEBPACK_IMPORTED_MODULE_4__assertions_js__["f" /* assertNotInAttributes */])('elementOpenStart');
    Object(__WEBPACK_IMPORTED_MODULE_4__assertions_js__["k" /* setInAttributes */])(true);
  }

  argsBuilder[0] = nameOrCtor;
  argsBuilder[1] = key;
  argsBuilder[2] = statics;
};


/***
 * Defines a virtual attribute at this point of the DOM. This is only valid
 * when called between elementOpenStart and elementOpenEnd.
 *
 * @param {string} name
 * @param {*} value
 */
const attr = function(name, value) {
  if (__WEBPACK_IMPORTED_MODULE_6__global_js__["a" /* global */].DEBUG) {
    Object(__WEBPACK_IMPORTED_MODULE_4__assertions_js__["b" /* assertInAttributes */])('attr');
  }

  argsBuilder.push(name);
  argsBuilder.push(value);
};


/**
 * Closes an open tag started with elementOpenStart.
 * @return {!Element} The corresponding Element.
 */
const elementOpenEnd = function() {
  if (__WEBPACK_IMPORTED_MODULE_6__global_js__["a" /* global */].DEBUG) {
    Object(__WEBPACK_IMPORTED_MODULE_4__assertions_js__["b" /* assertInAttributes */])('elementOpenEnd');
    Object(__WEBPACK_IMPORTED_MODULE_4__assertions_js__["k" /* setInAttributes */])(false);
  }

  const node = elementOpen.apply(null, argsBuilder);
  Object(__WEBPACK_IMPORTED_MODULE_5__util_js__["c" /* truncateArray */])(argsBuilder, 0);
  return node;
};


/**
 * Closes an open virtual Element.
 *
 * @param {NameOrCtorDef} nameOrCtor The Element's tag or constructor.
 * @return {!Element} The corresponding Element.
 */
const elementClose = function(nameOrCtor) {
  if (__WEBPACK_IMPORTED_MODULE_6__global_js__["a" /* global */].DEBUG) {
    Object(__WEBPACK_IMPORTED_MODULE_4__assertions_js__["f" /* assertNotInAttributes */])('elementClose');
  }

  const node = Object(__WEBPACK_IMPORTED_MODULE_1__core_js__["a" /* close */])();

  if (__WEBPACK_IMPORTED_MODULE_6__global_js__["a" /* global */].DEBUG) {
    Object(__WEBPACK_IMPORTED_MODULE_4__assertions_js__["a" /* assertCloseMatchesOpenTag */])(Object(__WEBPACK_IMPORTED_MODULE_3__node_data_js__["a" /* getData */])(node).nameOrCtor, nameOrCtor);
  }

  return node;
};


/**
 * Declares a virtual Element at the current location in the document that has
 * no children.
 * @param {NameOrCtorDef} nameOrCtor The Element's tag or constructor.
 * @param {?string=} key The key used to identify this element. This can be an
 *     empty string, but performance may be better if a unique value is used
 *     when iterating over an array of items.
 * @param {?Array<*>=} statics An array of attribute name/value pairs of the
 *     static attributes for the Element. These will only be set once when the
 *     Element is created.
 * @param {...*} var_args Attribute name/value pairs of the dynamic attributes
 *     for the Element.
 * @return {!Element} The corresponding Element.
 */
const elementVoid = function(nameOrCtor, key, statics, var_args) {
  elementOpen.apply(null, arguments);
  return elementClose(nameOrCtor);
};


/**
 * Declares a virtual Text at this point in the document.
 *
 * @param {string|number|boolean} value The value of the Text.
 * @param {...(function((string|number|boolean)):string)} var_args
 *     Functions to format the value which are called only when the value has
 *     changed.
 * @return {!Text} The corresponding text node.
 */
const text = function(value, var_args) {
  if (__WEBPACK_IMPORTED_MODULE_6__global_js__["a" /* global */].DEBUG) {
    Object(__WEBPACK_IMPORTED_MODULE_4__assertions_js__["f" /* assertNotInAttributes */])('text');
    Object(__WEBPACK_IMPORTED_MODULE_4__assertions_js__["g" /* assertNotInSkip */])('text');
  }

  const node = Object(__WEBPACK_IMPORTED_MODULE_1__core_js__["i" /* text */])();
  const data = Object(__WEBPACK_IMPORTED_MODULE_3__node_data_js__["a" /* getData */])(node);

  if (data.text !== value) {
    data.text = /** @type {string} */(value);

    let formatted = value;
    for (let i = 1; i < arguments.length; i += 1) {
      /*
       * Call the formatter function directly to prevent leaking arguments.
       * https://github.com/google/incremental-dom/pull/204#issuecomment-178223574
       */
      const fn = arguments[i];
      formatted = fn(formatted);
    }

    node.data = formatted;
  }

  return node;
};


/** */



/***/ })
/******/ ]);